# 20125071_Ex02

1. The console shows "Base constructor-0 param" because when b1 is initialized with no parameter, it will call the default constructor.
2. Next, the program prints on the console "Base constructor-1 param" because b2 is initialized with a parameter, the program uses the constructor with 1 parameter.
3. Pointer pb gets a newly allocated memory as Base and creates with 1 parameter, so the program prints "Base constructor-1 param".
4. Then, the console shows "Base constructor-0 param" and "DerivedA constructor-0 param" because da1 is created with no parameter, the program uses the default constructor and C++, by the default, will call the Base class first, then the constructor of DerivedA.
5. After that, because da2 is created with a parameter, the console shows "DerviedA constructor-1 param" because da1 is created with 1 parameter and we don't specify which constructor of Base that this one of DerivedA will call, by the default, will call the default constructor of Base class first, then the constructor of DerivedA.
6. Next, da3 is created with 2 parameters and we don't specify which constructor of Base that this one of DerivedA will call, by the default, will call the default constructor of Base class first, then the constructor of DerivedA. So, the program prints "Base constructor-0 param" and "DerivedA constructor-2 params".
7. Since da2 is DerivedA, da4 is created by a copy constructor and this constructor does not print anything out to the console, but, the program still calls the default constructor of Base. Hence at this step, the program only prints "Base constructor-0 param".
8. When pb points to a new DerivedA with 2 parameters, it invokes the default constructor of Base first then the one with 2 parameters of DerivedA. So, the console shows "Base constructor-0 param" and "DerivedA constructor-2 params"
9. Like da1, db1 is created with no parameter and we don't specify which constructor of Base is used when calling the default one of DerivedB, so the program constructs db1 by calling default constructors of Base and DerivedB. Hence, the console shows "Base constructor-0 param" and "DerivedB constructor-0 param".
10. db2 is created with 1 parameter and we don't specify which constructor of Base is used, so the program constructs db2 by the calling default constructor of Base and the one with 1 parameter. Hence, the console shows "Base constructor-1 param" and "DerivedB constructor-2 params"
11. Unlike the others, the constructor of DerivedB that has 2 parameters had been specified to use the constructor with 1 param of Base. So when creating db3 with 2 parameters, the program uses the constructor with 1 parameter and the one with 2 parameters of DerivedB. Hence, the console shows "Base constructor-1 param" and "DerivedB constructor-2 params".
12. We don't implement the copy constructor of DerivedB, C++ creates one, and this uses the copy constructor of DerivedB. So the program only prints "Base copy constructor".
13. To create a new DerivedB with 2 parameters for pb, the program calls the constructor with 1 parameter of Base and the one with 2 parameters of DerivedB. So, the console shows "Base constructor-1 param" and "DerivedB constructor-2 params"
14. Since the parameter of function *f* is Base, when calling the function *f*, DerivedA and DerivedB are converted to Base. And because b is a parameter passed by value, the program copies b1, da1, and db1 by using the copy constructor of Base. After doing function *f*, the program destroys b by calling the destructor of Base. Therefore, the console shows "Base copy constructor", "Function f" and "Base destructor" three times.
15. When deleting pb, the programs call the destructor of Base to free the memory used by pointer pb. So, the console shows "Base destructor".
16. After doing the main function, the program destroys b1, b2, da1, da2, da3, da4, db1, db2, db3, db4. In C++, when an object is destroyed, the destructor of the base class would be called first, then the one of the derived class. Hence, the program prints "DerivedA destructor" if the object is DerivedA or "DerivedB destructor" if it is DerivedB, and nothing if it is Base, then prints "Base destructor".